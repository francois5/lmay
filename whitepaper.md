# LMAY Markup for AI in YAML
## A Universal Declarative Standard for AI Understanding of Codebases

### 1. Executive Summary

The rapid evolution of AI-based programming assistants has revealed a fundamental challenge in the interaction between AI systems and complex codebases. While these tools are transforming the way we develop software, their effectiveness remains limited by their ability to quickly and accurately understand the structure and intent of a development project. LMAY (LMAY Markup for AI in YAML) offers an elegant solution to this problem by introducing a universal declarative standard for structured documentation of codebases.

LMAY provides an innovative approach that enables developers to create a semantic map of their project, instantly accessible to programming AIs. By leveraging the simplicity and readability of the YAML format, LMAY bridges the gap between the inherent complexity of modern software architectures and the need for AIs to navigate these structures efficiently. This approach significantly reduces the computational costs associated with code analysis while enhancing the accuracy and relevance of suggestions generated by AI assistants.

The value proposition of LMAY rests on three fundamental pillars. First, it offers a substantial reduction in the tokens required to understand a project, thereby decreasing operational costs and improving response times. Second, it establishes a common language between developers and AI, facilitating more natural and productive collaboration. Third, it creates a universal standard, independent of programming languages or frameworks, enabling widespread adoption across the technology ecosystem.

### 2. Introduction and Context

The emergence of AI-based programming assistants represents a revolution in software development. Tools such as GitHub Copilot, Claude Code, and others are transforming how we write, understand, and maintain code. However, despite their impressive capabilities, these systems face significant challenges when interacting with large or highly complex codebases.

The central problem lies in the inefficiency of the current approach, where AIs must analyze and interpret thousands of lines of code to understand the structure and functioning of a project. This repetitive analysis consumes considerable computational resources and introduces delays that impact the user experience. Furthermore, the lack of structured context forces AIs to make inferences that may prove incorrect, leading to inappropriate suggestions or partial understanding of the project.

Existing approaches to documenting code, such as inline comments, README files, or even automatic documentation tools, exhibit significant limitations in the context of AI. Comments are often inconsistent, outdated, or absent. README files provide an overview but lack a formal structure exploitable by machines. Automatic documentation tools generate large volumes of unstructured information that are difficult for an AI to navigate efficiently.

This situation creates a paradox where tools intended to accelerate development are slowed by their inability to quickly grasp the context in which they operate. The need for a universal declarative standard becomes evident when considering the scale at which these tools are deployed and the economic impact of their current inefficiency.

### 3. Conceptual Foundations of LMAY

The design philosophy of LMAY revolves around the recognition that documentation intended for AIs requires a fundamentally different approach from that intended for humans. While traditional documentation prioritizes narrative and detailed explanation, LMAY adopts a declarative approach that emphasizes structure, relationships, and metadata essential for algorithmic navigation.

The first guiding principle of LMAY is radical simplicity. Every element of the standard has been designed to minimize cognitive load for both human or AI agents writing it and for AIs consuming it. This simplicity does not sacrifice informational richness but channels it into a predictable and extensible structure. The use of YAML as the base format exemplifies this commitment to simplicity, offering clear syntax and natural hierarchy without the verbosity of XML or the rigidity of JSON.

Efficiency constitutes the second conceptual pillar of LMAY. In a context where each processed token represents a computational and financial cost, LMAY optimizes information density. Rather than duplicating information available in the source code, LMAY focuses on architectural and relational metadata that allow the AI to intelligently navigate to relevant sections of the code. This approach typically reduces the volume of data needed to understand a project's structure by 80 to 90 percent.

Universality represents the third foundation of LMAY. Unlike solutions specific to a language or framework, LMAY proposes an abstract vocabulary capable of describing any software architecture. This universality is not limited to programming languages but extends to architectural paradigms, enabling equally effective documentation of a traditional monolith, a microservices architecture, or a complex distributed system.

LMAY's positioning relative to existing solutions highlights its unique character. Unlike static analysis tools that attempt to extract structure from the code itself, LMAY adopts a collaborative approach where the developer explicitly provides key architectural information. This method eliminates ambiguity and interpretation errors while remaining lightweight enough to be maintained as the project evolves. Compared to existing documentation standards, LMAY stands out for its machine-first orientation, optimizing for algorithmic consumption rather than human reading, while remaining sufficiently readable for manual editing by developers.

### 4. Technical Architecture

The technical architecture of LMAY is based on a carefully designed hierarchical structure that reflects the natural organization of modern software projects. This architecture establishes a predictable and efficient navigation system, allowing artificial intelligences to quickly understand the topology of a codebase without requiring exhaustive analysis of the source code.

At the core of this architecture is the `root.lmay` file, which must be positioned at the root of the project. This file serves as the single and canonical entry point for any exploration by an AI. It contains the essential metadata of the project as well as the navigation map to the main components. This centralized approach eliminates ambiguity regarding the starting point of the analysis and ensures a consistent experience regardless of the project’s complexity.

The chaining system implemented by LMAY enables progressive and contextual exploration of the codebase. Each LMAY file can point to lower-level LMAY files, creating a navigation graph that accurately reflects the project’s logical architecture. This recursive approach offers several significant advantages. First, it allows individual files to remain compact and focused on their specific domain. Second, it facilitates maintenance by localizing changes to their appropriate context. Finally, it optimizes navigation by enabling AIs to descend into the hierarchy only when necessary for the task at hand.

The choice of YAML as the syntactic foundation of LMAY stems from a thorough analysis of the specific needs for AI-oriented documentation. YAML offers a unique combination of human readability and machine-parsability that distinguishes it from alternatives. Its minimalist syntax reduces visual noise while maintaining sufficient expressiveness to represent complex structures. YAML’s natural indentation intuitively corresponds to architectural hierarchies, facilitating immediate understanding of the documented structure. Additionally, the ubiquity of YAML parsers in all major programming languages ensures easy adoption without additional dependencies.

### 5. LMAY v1.0 Format Specification

The formal specification of LMAY v1.0 establishes a precise and extensible vocabulary for the declarative documentation of codebases. This specification defines the fundamental syntactic elements while preserving the flexibility needed to adapt to future developments in development practices.

The `root.lmay` file is the cornerstone of any LMAY documentation. Its structure includes several mandatory sections that capture the essence of the project. The identification section contains the LMAY version number used, ensuring future compatibility. The project section provides essential metadata, including the name, version, a concise description, the programming languages used, and the main frameworks. The architecture section describes the overall architectural pattern and identifies the application’s main entry point. The structure section maps the project’s main directories, associating each with its corresponding LMAY file and briefly describing its role. The `dependencies` and `interfaces` sections complete this overview by documenting external dependencies and the system’s interaction points.

Submodule files follow a consistent structure but are tailored to their specific context. Each file begins with the identification of the LMAY version and a module section that specifies the type of component documented and its role in the overall architecture. The depth in the hierarchy is explicitly indicated, along with a reference to the parent file, facilitating bidirectional navigation. Individual components are documented with their public exports, internal dependencies, and their relative criticality to the system’s operation.

The recursion mechanism implemented in LMAY allows for in-depth documentation while maintaining structural clarity. Each level of the hierarchy can define its own submodules, creating a faithful representation of complex architectures. This recursion is controlled by depth and complexity indicators that guide AIs in their navigation decisions. A practical limit of three levels of depth is recommended to maintain a balance between comprehensiveness and efficiency.

LMAY’s naming conventions and syntactic rules prioritize conciseness without sacrificing clarity. Paths always use relative references to ensure portability. Descriptions are limited to one hundred characters to enforce concise expression of concepts. Boolean values for properties such as "critical" or "stable" provide clear binary signals to optimize algorithmic navigation.

### 6. Documentation Patterns

The effectiveness of LMAY largely depends on the establishment of standardized documentation patterns that consistently and predictably capture common software architectures. These patterns serve as reusable templates that accelerate adoption while ensuring uniform documentary quality across different projects and teams.

For Model-View-Controller architectures, LMAY proposes a documentation structure that naturally reflects the separation of concerns inherent in this pattern. The root file identifies the architecture as MVC and points to three distinct LMAY files for models, views, and controllers. Each file not only documents the components it contains but also the data flows and cross-layer dependencies. This approach allows AIs to immediately understand the responsibilities of each layer, navigate efficiently based on the task context, and better avoid regression by limiting contextual misunderstanding errors.

Microservices architectures present unique challenges that LMAY addresses through a distributed yet consistent documentation pattern. Each microservice maintains its own LMAY file documenting its public interfaces, external dependencies, and communication patterns. The `root.lmay` file at the project level aggregates this information to provide an overview of the ecosystem, including orchestration patterns, service discovery mechanisms, and implemented resilience strategies.

Dependency management in LMAY goes beyond merely listing external packages. The format distinguishes critical dependencies from optional ones, documents version constraints with their justification, and captures significant transitive relationships. This informational richness enables AIs to understand not only which dependencies are present but also why they are necessary and how they interact with the overall system.

Optimization metadata is a crucial aspect of LMAY patterns. This metadata includes stability indicators that signal portions of the code rarely modified, enabling intelligent caching strategies. Complexity markers guide AIs in allocating their computational resources, focusing in-depth analysis on sections that benefit most. Criticality tags identify components essential to the system’s operation, allowing for intelligent prioritization during analysis or code generation.

The natural evolution of LMAY documentation patterns anticipates the emergence of specialized vocabularies for specific domains. Artificial intelligence applications could document their data pipelines and model architectures. Blockchain systems could capture their smart contracts and consensus mechanisms. This extensibility ensures that LMAY remains relevant amid the continuous evolution of software development paradigms.

### 7. Use Cases and Examples

The practical application of LMAY is particularly evident through concrete examples that illustrate its versatility and effectiveness across various development contexts. These use cases demonstrate how LMAY transforms the way artificial intelligences understand and navigate diverse software architectures.

Consider first a full-stack web application developed with Node.js and Vue.js, representative of modern web development architectures. In this context, the `root.lmay` file captures the overall architecture by clearly identifying the separation between the REST API backend and the SPA frontend. The backend, documented in its own `api.lmay` file, details the available endpoints, authentication middleware, and connections to MongoDB databases. The frontend, referenced by a `frontend.lmay` file, documents the structure of Vue components, Vuex stores for state management, and routing patterns. This organization allows an AI to instantly understand that user interface modifications reside in the frontend directory, while business logic lies in the backend services, thus avoiding unnecessary exploration of irrelevant code portions.

A machine learning project in Python presents different documentary challenges that LMAY addresses elegantly. The `root.lmay` file identifies the typical structure of an ML project with its data directories, notebooks, models, and pipelines. Specialized LMAY files document the data transformations applied, the model architectures used, and the evaluation metrics implemented. Critical dependencies such as TensorFlow or PyTorch are marked with their specific versions, essential for reproducibility. This structured documentation enables AIs to navigate efficiently between data exploration, model training, and deployment, understanding the connections between these phases without analyzing the entirety of often voluminous Jupyter notebooks.

The microservices architecture with orchestration represents the most complex use case where LMAY demonstrates its maximum value. In an ecosystem comprising a dozen microservices, each service maintains its own LMAY file documenting its specific responsibilities, exposed APIs, and dependencies on other services. The `root.lmay` file at the project level provides an overview of the orchestration, documenting asynchronous communication patterns, message queues used, and resilience mechanisms such as circuit breakers. Critical services like authentication or payment processing are marked as such, enabling AIs to prioritize their understanding during tasks involving security or financial transactions. This approach drastically reduces the time required for an AI to comprehend complex inter-service interactions, from several minutes of analysis to a few seconds of structured navigation. Additionally, services can be declared `read-only` or `forbidden` to elegantly control AI access, for example, to sanctuarize sensitive parts of a software, ensuring they are not algorithmically modified.

### 8. Integration into the Development Ecosystem

The successful adoption of LMAY requires seamless integration into existing development workflows, without disrupting established practices while delivering immediate value to development teams. This integration is built around three main axes that ensure progressive and non-intrusive adoption.

Automatic generation tools constitute the first pillar of this integration. These tools analyze existing codebases to generate an initial version of LMAY files, significantly lowering the entry barrier for established projects. Static code analysis identifies architectural patterns, extracts dependencies, and infers relationships between components. This initial generation, though imperfect, provides a solid foundation that developers can refine to capture nuances specific to their project. The tools evolve continuously, learning from manual corrections to enhance the accuracy of future generations.

Integration with integrated development environments represents the second critical aspect of the LMAY ecosystem. Plugins for Visual Studio Code, IntelliJ IDEA, and other popular IDEs offer bidirectional synchronization between code and its LMAY documentation. When a developer creates a new module or modifies the architecture, the plugin automatically suggests corresponding updates in the LMAY files. This contextual assistance keeps the documentation up to date without additional conscious effort. The plugins also provide visualizations of the architecture based on LMAY files, offering immediate understanding of the project structure, particularly beneficial for new team members.

Integration into continuous integration and continuous deployment pipelines ensures consistency between code and its LMAY documentation. Automatic validators verify that LMAY files accurately reflect the current code structure, reporting discrepancies as build errors. This approach transforms documentation maintenance from an optional, often neglected task into a quality requirement on par with unit tests. LMAY coverage metrics enable teams to track the completeness of their documentation and identify areas needing attention.

Compatibility with existing workflows is demonstrated by LMAY’s non-intrusive design. LMAY files coexist peacefully with other documentation artifacts without replacing them. Developers can adopt LMAY progressively, starting with documenting critical components before extending coverage. This incremental approach respects teams’ time and resource constraints while showcasing immediate value for interactions with programming AIs.

### 9. Performance and Optimization

The impact of LMAY on the performance of artificial intelligence systems is one of its most compelling arguments, demonstrating measurable improvements in both processing speed and economic efficiency. These performance gains stem from a fundamentally innovative approach to the interaction between AI and codebase.

Analysis of token gains reveals the extent of the optimization brought by LMAY. Comparative benchmarks on medium-sized projects remain to be conducted, but it is certain that, by design, the use of LMAY will drastically reduce the number of tokens needed to understand project architectures, likely by approximately 90%. This significant reduction is due to the elimination of repetitive source code parsing and the focus on essential architectural metadata. For a typical task requiring the understanding of three interconnected modules, reducing from, for example, 20,000 tokens to 2,000 tokens represents not only substantial financial savings but also a proportional reduction in processing time.

Intelligent caching strategies enabled by LMAY amplify these initial performance gains. Stability metadata included in LMAY files allow AI systems to identify portions of the code that rarely change and maintain cached representations of their structure. This approach eliminates the need to reparse stable components with each interaction, further reducing computational load. Criticality indicators guide the intelligent allocation of cache memory, prioritizing frequently accessed essential components. In active development environments, these caching optimizations can likely reduce response times by 70% for repetitive queries.

Comparative benchmarks between traditional approaches and the use of LMAY will reveal consistent improvements across various task types. For contextual code generation, LMAY will enable an average reduction in first response time of 65%. In refactoring tasks requiring understanding of complex dependencies, the improvement will reach 80%. These gains translate directly into an enhanced user experience, with faster and more relevant suggestions, reinforcing the adoption of AI tools in the daily development flow.

Optimization is not limited to raw performance but extends to the quality of the results produced. Structured navigation enabled by LMAY eliminates common interpretation errors when AIs attempt to infer architecture from code alone. This increased accuracy manifests as a 50% reduction in incorrect or out-of-context suggestions, boosting developers’ confidence in AI tools and reducing the time spent filtering irrelevant suggestions.

### 10. Governance and Evolution

The sustainability and success of LMAY fundamentally depend on establishing a robust governance structure that balances innovation and stability. This governance must allow for the continuous evolution of the standard while preserving the backward compatibility essential to adopters’ trust. The proposed approach draws inspiration from proven governance models of open standards while integrating lessons learned from past failures in this domain.

The community contribution process lies at the heart of LMAY governance. This process revolves around a structured system of improvement proposals, akin to RFCs but tailored to the specific needs of a documentation standard. Each proposal follows a defined lifecycle, beginning with an open discussion phase where the community can debate the merits and implications of the proposed change. Proposals demonstrating positive consensus then proceed to a prototype phase, where reference implementations are developed and tested on real projects. This empirical approach ensures that standard evolutions address concrete needs rather than theoretical considerations.

LMAY versioning adopts a rigorous semantic approach that clearly communicates the nature and impact of changes. Major versions signal potentially incompatible changes, though the goal remains to minimize such occurrences. Minor versions introduce new features while maintaining full backward compatibility. Patch versions correct ambiguities or errors in the specification without altering expected behavior. This predictability allows development teams and tool creators to plan their updates with confidence.

The roadmap for LMAY’s future evolution reflects emerging trends in software development and artificial intelligence. Planned extensions include specialized vocabularies for domains such as blockchain development, the Internet of Things, and cyber-physical systems. The integration of security metadata will enable AIs to understand and respect security constraints when generating code. The evolution toward behavioral analysis capabilities will allow documenting not only static structure but also dynamic execution patterns of systems.

The organizational structure overseeing LMAY combines industrial and academic representation to ensure the standard remains grounded in practice while benefiting from the latest research advances. A technical committee, composed of representatives from major technology companies, significant open-source projects, and academic institutions, guides strategic decisions. This committee operates on principles of total transparency, with all deliberations and decisions published openly. Regular rotation of members ensures the renewal of perspectives while maintaining the institutional continuity necessary for the standard’s stability.

### 11. Adoption and Migration

The transition to LMAY represents a strategic investment for many organizations in the future efficiency of their AI-assisted development. This transition must be carefully orchestrated to minimize disruption while maximizing immediate benefits. The proposed adoption approach acknowledges the diversity of organizational contexts and offers flexible pathways tailored to different maturities and constraints.

The quick-start guide for LMAY favors a pragmatic approach that demonstrates immediate value. Organizations typically begin by identifying a medium-sized pilot project, complex enough to illustrate LMAY’s benefits but contained enough to allow complete implementation within a few days. Installing automatic generation tools enables the creation of an initial draft of LMAY documentation in less than an hour for most projects. This automatically generated base is then refined by the development team to capture architectural nuances and design decisions not evident in the source code. This initial refinement phase would represent an investment of four to eight hours for a medium-sized project, a cost quickly amortized by subsequent efficiency gains.

Migration strategies for existing projects vary depending on the size and complexity of the codebase concerned. For large monolithic projects, an incremental approach should prove most effective. This strategy begins by documenting public interfaces and main entry points, thus creating a navigable skeleton even if incomplete. Teams progressively extend LMAY coverage based on needs, prioritizing frequently modified or particularly complex modules. This approach allows immediate benefits from LMAY for AI interactions while spreading the documentation effort over several development sprints.

Microservices architectures benefit from a distributed migration strategy where each team responsible for a service adopts LMAY independently. This decentralized approach accelerates overall adoption while respecting team autonomy. A minimal `root.lmay` file at the project level can be created immediately, evolving organically as individual services add their LMAY documentation. This strategy has demonstrated higher adoption rates as it aligns the documentation effort with direct benefits for each team.

The emerging ecosystem around LMAY significantly facilitates adoption by providing specialized resources and tools. Templates specific to popular frameworks enable quick starts for common architectures. Online training and emerging certifications create a pool of developers familiar with LMAY best practices. Practice communities share proven documentation patterns and solutions to common adoption challenges. Integrations with native cloud development platforms enable automatic generation and maintenance of LMAY files based on deployed infrastructure.

Measuring the return on investment of LMAY adoption will reveal quantifiable benefits that justify the initial effort. Organizations will report the average reduction in time required for new developers to become productive on a project. The efficiency of AI tools will increase measurably when interacting with this machine-first technology, with a radical increase in accepted suggestion rates in the first months following LMAY adoption. These improvements translate directly into accelerated development cycles and reduced operational costs, positioning LMAY as a strategic investment rather than an additional expense.

### 12. Conclusion and Call to Action

The emergence of LMAY marks a pivotal moment in the evolution of collaboration between developers and artificial intelligences. This universal declarative standard transcends mere technical improvement to propose a fundamental transformation in how we design, document, and share architectural knowledge of our software systems. The convergence of conceptual simplicity, computational efficiency, and universality of application positions LMAY as essential infrastructure for the era of AI-assisted programming.

The quantifiable benefits of LMAY extend well beyond immediate performance gains. The drastic reduction in computational costs, precisely measurable by the decrease in tokens needed to understand an architecture, transforms the economics of AI development assistance. This increased efficiency democratizes access to advanced AI tools, enabling teams of all sizes to benefit from sophisticated contextual assistance. The standardization brought by LMAY eliminates the current fragmentation of documentation approaches, creating a common language that facilitates inter-team collaboration and accelerates the integration of new developers.

The qualitative impact of LMAY on the development experience merits particular attention. Structured and predictable navigation transforms interactions with AI assistants from frustrating trial-and-error sessions with cascading regressions into productive and focused dialogues. The increased accuracy of generated suggestions strengthens developers’ confidence in these tools, promoting their deeper adoption in the development cycle. The facilitated maintenance of architectural documentation addresses one of the persistent challenges of software development, transforming a task often neglected by developers into a process naturally integrated into the daily workflow.

The call to action for the global technology community is clear and urgent. Pioneering organizations adopting LMAY today position their teams at the forefront of the AI-assisted programming revolution. Individual developers mastering LMAY acquire a differentiating skill in a rapidly evolving market. Tool and platform creators integrating LMAY offer their users a measurable competitive advantage. This window of opportunity to influence the standard’s direction and establish best practices will not remain open indefinitely.

The next concrete steps for the community revolve around three priority axes of action. First, active experimentation with LMAY on real projects generates the essential feedback for the standard’s evolution. Second, contributing to the development of tools and integrations accelerates the ecosystem and facilitates widespread adoption. Third, participating in governance discussions ensures that LMAY evolves to meet the real needs of the community rather than isolated theoretical visions. Each individual action contributes to the collective realization of a future where human-machine collaboration in software development reaches its full potential.

## Appendices

### Appendix A: Complete Reference of LMAY v1.0 Syntax

```yaml
# Structure of the root.lmay file
lmay: "1.0"                           # LMAY version (required)

project:                              # Project metadata (required)
  name: string                        # Project name
  version: string                     # Project version (semver)
  description: string                 # Description (max 100 characters)
  language: [string]                  # List of languages used
  framework: [string]                 # List of main frameworks

architecture:                         # Overall architecture (required)
  pattern: string                     # mvc|microservices|layered|hexagonal|event-driven
  entry: string                       # Main entry point (relative path)

structure:                            # Main structure (required)
  - path: string                      # Relative path of the directory
    lmay: string                      # Path to the LMAY file (optional)
    purpose: string                   # Description of the role (max 100 characters)

dependencies:                         # External dependencies (optional)
  runtime:                           # Runtime dependencies
    - name: string                   # Package name
      version: string                # Version constraint
      critical: boolean              # Criticality (optional, default: false)
  dev:                              # Development dependencies
    - name: string
      version: string

interfaces:                          # Interaction points (optional)
  api:                              # Exposed APIs
    - endpoint: string              # URL pattern
      protocol: string              # REST|GraphQL|gRPC|WebSocket
      auth: string                  # Authentication method
  database:                         # Database connections
    - type: string                  # Database type
      connection: string            # Connection reference

# Structure of submodule files
lmay: "1.0"                         # LMAY version (required)

module:                             # Module information (required)
  type: string                      # service|controller|model|component|utility
  purpose: string                   # Description (max 100 characters)
  depth: integer                    # Depth in the hierarchy (0 = root)
  parent: string                    # Relative path to the parent LMAY

components:                         # Module components (optional)
  - name: string                    # Component name
    file: string                    # Source file
    exports: [string]               # Exported elements
    dependencies: [string]          # Internal dependencies
    critical: boolean               # Criticality (optional)
    stable: boolean                 # Stability (optional)

submodules:                         # Submodules (optional)
  - path: string                    # Relative path
    lmay: string                    # Associated LMAY file
    purpose: string                 # Description
    complexity: string              # low|medium|high

patterns:                           # Patterns used (optional)
  - type: string                    # singleton|factory|observer|etc
    applies_to: [string]            # Affected components

# Data types
string: Character string
integer: Integer
boolean: true|false
[type]: List of elements of the specified type
```

### Appendix B: Glossary of LMAY Terms

**Architecture Pattern**: High-level structural organization model defining how system components interact. Accepted values: mvc, microservices, layered, hexagonal, event-driven, serverless, monolithic.

**Chaining**: Hierarchical linking mechanism between LMAY files allowing navigation from the root to the leaves of the documentary tree.

**Complexity**: Indicator guiding AI resource allocation. Values: low (simple logic), medium (standard business logic), high (complex algorithms or orchestration).

**Component**: Documented logical unit representing a class, function, module, or service with defined responsibilities and public interfaces.

**Critical**: Boolean marker indicating that a component is essential to the system’s operation. Critical components are prioritized during AI analysis.

**Read-only**: Boolean marker indicating that a component can be read during AI analysis but not modified by the machine.

**Forbidden**: Boolean marker indicating that a component is ignored during AI analysis.

**Depth**: Hierarchical level of an LMAY file. The root has a depth of 0, its direct children a depth of 1, etc.

**Export**: Public element of a module accessible from the outside (function, class, constant, type).

**Interface**: Documented interaction point between the system and the outside (REST API, GraphQL, database, message queue).

**Pattern**: Design pattern applied in the code (singleton, factory, repository, observer, strategy).

**Stability**: Expected frequency of modification. Values: stable (rarely modified), evolving (regular modifications), volatile (frequent changes).

**Submodule**: Child module in the LMAY hierarchy, representing a logical subdivision of a parent module.

### Appendix C: Complete Examples of LMAY Files

#### Example 1: Node.js/MongoDB E-commerce Application

```yaml
# root.lmay
lmay: "1.0"

project:
  name: "ecommerce-api"
  version: "2.1.0"
  description: "REST API for B2C e-commerce platform"
  language: ["javascript", "typescript"]
  framework: ["express", "mongoose"]

architecture:
  pattern: "layered"
  entry: "src/server.js"

structure:
  - path: "src/controllers"
    lmay: "src/controllers/controllers.lmay"
    purpose: "REST endpoints and presentation logic"
    
  - path: "src/services"
    lmay: "src/services/services.lmay"
    purpose: "Business logic and orchestration"
    
  - path: "src/models"
    lmay: "src/models/models.lmay"
    purpose: "MongoDB schemas and data logic"
    
  - path: "src/middleware"
    purpose: "Authentication, validation, logging"
    
  - path: "src/utils"
    purpose: "Shared utility functions"

dependencies:
  runtime:
    - name: "express"
      version: "^4.18.2"
      critical: true
    - name: "mongoose"
      version: "^7.0.0"
      critical: true
    - name: "jsonwebtoken"
      version: "^9.0.0"
      critical: true
    - name: "stripe"
      version: "^11.0.0"
  dev:
    - name: "jest"
      version: "^29.0.0"
    - name: "supertest"
      version: "^6.3.0"

interfaces:
  api:
    - endpoint: "/api/v1/products/*"
      protocol: "REST"
      auth: "public"
    - endpoint: "/api/v1/orders/*"
      protocol: "REST"
      auth: "JWT"
    - endpoint: "/api/v1/users/*"
      protocol: "REST"
      auth: "JWT"
  database:
    - type: "mongodb"
      connection: "env:MONGODB_URI"
```

```yaml
# src/services/services.lmay
lmay: "1.0"

module:
  type: "service_group"
  purpose: "Business services for e-commerce management"
  depth: 1
  parent: "../../root.lmay"

components:
  - name: "OrderService"
    file: "order.service.js"
    exports: ["createOrder", "updateOrderStatus", "calculateShipping", "processPayment"]
    dependencies: ["ProductService", "UserService", "PaymentGateway"]
    critical: true
    
  - name: "ProductService"
    file: "product.service.js"
    exports: ["searchProducts", "updateInventory", "calculatePricing", "getRecommendations"]
    dependencies: ["CacheService", "SearchEngine"]
    stable: true
    
  - name: "CartService"
    file: "cart.service.js"
    exports: ["addToCart", "updateQuantity", "applyDiscount", "validateCart"]
    dependencies: ["ProductService", "PricingEngine"]

submodules:
  - path: "payment"
    lmay: "payment/payment.lmay"
    purpose: "Integrations with payment processors"
    complexity: "high"
    
  - path: "shipping"
    lmay: "shipping/shipping.lmay"
    purpose: "Shipping calculations and carrier integrations"
    complexity: "medium"

patterns:
  - type: "strategy"
    applies_to: ["PaymentGateway", "ShippingCalculator"]
  - type: "decorator"
    applies_to: ["PricingEngine"]
```

#### Example 2: React Application with Redux

```yaml
# root.lmay
lmay: "1.0"

project:
  name: "dashboard-app"
  version: "1.0.0"
  description: "Real-time analytics dashboard"
  language: ["javascript", "jsx"]
  framework: ["react", "redux", "mui"]

architecture:
  pattern: "component-based"
  entry: "src/index.js"

structure:
  - path: "src/components"
    lmay: "src/components/components.lmay"
    purpose: "Reusable React components"
    
  - path: "src/features"
    lmay: "src/features/features.lmay"
    purpose: "Functional modules with local state"
    
  - path: "src/store"
    lmay: "src/store/store.lmay"
    purpose: "Redux configuration and global state"
    
  - path: "src/services"
    purpose: "API calls and external logic"
    
  - path: "src/hooks"
    purpose: "Custom React hooks"

dependencies:
  runtime:
    - name: "react"
      version: "^18.2.0"
      critical: true
    - name: "redux"
      version: "^4.2.0"
      critical: true
    - name: "@mui/material"
      version: "^5.11.0"
    - name: "recharts"
      version: "^2.5.0"
```

```yaml
# src/features/features.lmay
lmay: "1.0"

module:
  type: "component_group"
  purpose: "Autonomous functional modules of the application"
  depth: 1
  parent: "../../root.lmay"

components:
  - name: "Analytics"
    file: "analytics/index.js"
    exports: ["AnalyticsView", "analyticsSlice", "useAnalyticsData"]
    dependencies: ["Chart", "DataGrid", "apiService"]
    critical: true
    
  - name: "UserManagement"
    file: "users/index.js"
    exports: ["UserList", "UserForm", "userSlice"]
    dependencies: ["Table", "Form", "authService"]
    
  - name: "Reports"
    file: "reports/index.js"
    exports: ["ReportGenerator", "ReportViewer", "reportSlice"]
    dependencies: ["PDFExporter", "ChartExporter"]

submodules:
  - path: "analytics/components"
    lmay: "analytics/components.lmay"
    purpose: "Components specific to analytics"
    complexity: "medium"
    
  - path: "analytics/hooks"
    purpose: "Hooks for real-time data"
    complexity: "low"

patterns:
  - type: "container-presenter"
    applies_to: ["AnalyticsView", "UserList", "ReportGenerator"]
  - type: "redux-toolkit-slice"
    applies_to: ["analyticsSlice", "userSlice", "reportSlice"]
```

---

*LMAY v1.0 - July 2025*

*To contribute to the development of LMAY or for more information, visit https://github.com/francois5/lmay*